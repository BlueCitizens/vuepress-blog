import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as n,o as s,c as p,a,b as h,d as r,e as l}from"./app-B1G4RYfZ.js";const o={},i=l('<h1 id="java数据结构之hashmap" tabindex="-1"><a class="header-anchor" href="#java数据结构之hashmap"><span>Java数据结构之HashMap</span></a></h1><p>HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h2><p>整体为数组，数组的元素是一个个链表，每个链表当中串有若干node。</p><h3 id="为什么是链表" tabindex="-1"><a class="header-anchor" href="#为什么是链表"><span>为什么是链表？</span></a></h3><p>数组的容量是有限个数的。插入键值对实例时使用哈希算法，先基于哈希函数计算键值的索引（数组的下标），然后插入对应的位置。当发生碰撞时，对比键值是否相等，相等则覆盖，不相等则将新键值对插入到对应位置的链表中。</p><h3 id="扩容机制" tabindex="-1"><a class="header-anchor" href="#扩容机制"><span>扩容机制</span></a></h3><p>当元素个数大于阈值时扩容，使用2倍大小的新数组代替旧数组，将原数组拷贝到新数组。这个阈值是根据数组长度和loadFactor（负载因子）决定的，默认为0.75。</p><h3 id="红黑树转化-jdk-1-8" tabindex="-1"><a class="header-anchor" href="#红黑树转化-jdk-1-8"><span>红黑树转化（JDK 1.8）</span></a></h3><p>当链表长度大于8且数组长度大于64时，链表会转化为红黑树。转化的目的是为了改善查找的时间复杂度。</p><p>当位于同一个链表中的元素很多（哈希值相等但键值不同）时，通过遍历查找键值比较低效。</p><h2 id="为什么hashmap是线程不安全的" tabindex="-1"><a class="header-anchor" href="#为什么hashmap是线程不安全的"><span>为什么hashMap是线程不安全的？</span></a></h2><h3 id="数据覆盖-jdk-1-8" tabindex="-1"><a class="header-anchor" href="#数据覆盖-jdk-1-8"><span>数据覆盖（JDK 1.8）</span></a></h3><p>两个线程同时进行put操作时，A线程冲突检测后未完成插入就挂起，B线程正常完成插入，那么A线程在被唤起继续插入后可能会覆盖B线程插入的值。</p><h3 id="concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap"><span>ConcurrentHashMap</span></a></h3><h2 id="quote" tabindex="-1"><a class="header-anchor" href="#quote"><span>Quote</span></a></h2>',16),c={href:"https://blog.csdn.net/qq_37084904/article/details/109243886",target:"_blank",rel:"noopener noreferrer"};function d(u,m){const e=n("ExternalLinkIcon");return s(),p("div",null,[i,a("p",null,[a("a",c,[h("详细理解HashMap数据结构，太齐全了！"),r(e)])])])}const k=t(o,[["render",d],["__file","Java数据结构之HashMap.html.vue"]]),_=JSON.parse(`{"path":"/posts/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BHashMap.html","title":"Java数据结构之HashMap","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2023-12-04T00:00:00.000Z","category":["开发"],"Tag":["Java"],"description":"Java数据结构之HashMap HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 数据结构 整体为数组，数组的元素是一个个链表，每个链表当中串有若干node。 为...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BHashMap.html"}],["meta",{"property":"og:site_name","content":"BCkun's BLOG"}],["meta",{"property":"og:title","content":"Java数据结构之HashMap"}],["meta",{"property":"og:description","content":"Java数据结构之HashMap HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 数据结构 整体为数组，数组的元素是一个个链表，每个链表当中串有若干node。 为..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-27T02:44:22.000Z"}],["meta",{"property":"article:author","content":"BlueCitizen"}],["meta",{"property":"article:published_time","content":"2023-12-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-27T02:44:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java数据结构之HashMap\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-04T00:00:00.000Z\\",\\"dateModified\\":\\"2024-02-27T02:44:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"BlueCitizen\\",\\"url\\":\\"https://bckun.top\\"}]}"]]},"headers":[{"level":2,"title":"数据结构","slug":"数据结构","link":"#数据结构","children":[{"level":3,"title":"为什么是链表？","slug":"为什么是链表","link":"#为什么是链表","children":[]},{"level":3,"title":"扩容机制","slug":"扩容机制","link":"#扩容机制","children":[]},{"level":3,"title":"红黑树转化（JDK 1.8）","slug":"红黑树转化-jdk-1-8","link":"#红黑树转化-jdk-1-8","children":[]}]},{"level":2,"title":"为什么hashMap是线程不安全的？","slug":"为什么hashmap是线程不安全的","link":"#为什么hashmap是线程不安全的","children":[{"level":3,"title":"数据覆盖（JDK 1.8）","slug":"数据覆盖-jdk-1-8","link":"#数据覆盖-jdk-1-8","children":[]},{"level":3,"title":"ConcurrentHashMap","slug":"concurrenthashmap","link":"#concurrenthashmap","children":[]}]},{"level":2,"title":"Quote","slug":"quote","link":"#quote","children":[]}],"git":{"createdTime":1709001862000,"updatedTime":1709001862000,"contributors":[{"name":"BlueCitizens","email":"bluecitizens@163.com","commits":1}]},"readingTime":{"minutes":1.58,"words":473},"filePathRelative":"posts/Java数据结构之HashMap.md","localizedDate":"2023年12月4日","excerpt":"\\n<p>HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>\\n<h2>数据结构</h2>\\n<p>整体为数组，数组的元素是一个个链表，每个链表当中串有若干node。</p>\\n<h3>为什么是链表？</h3>\\n<p>数组的容量是有限个数的。插入键值对实例时使用哈希算法，先基于哈希函数计算键值的索引（数组的下标），然后插入对应的位置。当发生碰撞时，对比键值是否相等，相等则覆盖，不相等则将新键值对插入到对应位置的链表中。</p>","autoDesc":true}`);export{k as comp,_ as data};
